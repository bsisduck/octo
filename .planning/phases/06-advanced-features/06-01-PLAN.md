---
phase: 06-advanced-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/docker/interface.go
  - internal/docker/client.go
  - internal/docker/mock.go
  - internal/docker/types.go
  - internal/docker/timeout.go
  - internal/docker/exec.go
  - internal/tui/analyze/model.go
  - internal/tui/common/messages.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "User can press 'x' on a running container in the analyze TUI and enter an interactive shell inside it"
    - "Shell session has working stdin/stdout with proper terminal raw mode"
    - "Resizing the terminal during exec propagates to the container (SIGWINCH forwarding)"
    - "Exiting the shell cleanly restores the TUI with refreshed data"
    - "Pressing 'x' on a non-running container shows an error message, not a crash"
  artifacts:
    - path: "internal/docker/exec.go"
      provides: "DockerExecCommand implementing tea.ExecCommand"
      contains: "func (d *DockerExecCommand) Run() error"
    - path: "internal/docker/interface.go"
      provides: "Exec methods on DockerAPI and DockerService"
      contains: "ContainerExecCreate"
    - path: "internal/docker/client.go"
      provides: "ExecContainer service method implementation"
      contains: "func (c *Client) ExecContainer"
    - path: "internal/tui/analyze/model.go"
      provides: "x-key handler dispatching tea.Exec"
      contains: "tea.Exec"
  key_links:
    - from: "internal/tui/analyze/model.go"
      to: "internal/docker/exec.go"
      via: "tea.Exec(NewDockerExecCommand(...))"
      pattern: "tea\\.Exec"
    - from: "internal/docker/exec.go"
      to: "internal/docker/interface.go"
      via: "DockerAPI methods for exec lifecycle"
      pattern: "ContainerExecCreate|ContainerExecAttach"
    - from: "internal/docker/exec.go"
      to: "golang.org/x/term"
      via: "MakeRaw/Restore/GetSize for terminal management"
      pattern: "term\\.MakeRaw|term\\.Restore"
---

<objective>
Add container exec/shell capability: user presses "x" on a running container in the analyze TUI to open an interactive shell inside it, with full PTY handling, SIGWINCH resize forwarding, and clean terminal restoration.

Purpose: This is the highest-complexity feature in the project (R26). It requires orchestrating Bubble Tea's terminal handoff (tea.Exec), Docker SDK's exec API, raw terminal mode, signal forwarding, and I/O streaming.
Output: Working exec/shell feature accessible via "x" key in analyze view.
</objective>

<execution_context>
@/Users/kamilkrawczyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kamilkrawczyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-advanced-features/06-RESEARCH.md
@internal/docker/interface.go
@internal/docker/client.go
@internal/docker/mock.go
@internal/docker/types.go
@internal/docker/timeout.go
@internal/tui/analyze/model.go
@internal/tui/common/messages.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker exec infrastructure -- interface, types, client, mock, dependency</name>
  <files>
    internal/docker/interface.go
    internal/docker/types.go
    internal/docker/client.go
    internal/docker/mock.go
    internal/docker/timeout.go
    go.mod
    go.sum
  </files>
  <action>
CRITICAL LINTER BLOCKER: golangci-lint formatter has previously removed new interface methods from interface.go. To work around this:
- Add ALL interface methods, ALL implementations, and ALL mock methods in a SINGLE task so the linter sees everything as used simultaneously.
- Run `go build ./...` BEFORE running the linter to verify compilation.
- If `make lint` removes interface methods, the issue is `unused` linter flagging interface methods that have no callers yet. The solution is to add at least one caller (the ExecContainer implementation in client.go calls the DockerAPI methods, and the mock implements DockerService methods).

1. **Add dependency:** Run `go get golang.org/x/term` to add it as a direct dependency.

2. **types.go** -- Add ExecOptions type:
```go
// ExecOptions configures an interactive exec session
type ExecOptions struct {
    ContainerID string
    Shell       string // "/bin/sh" or "/bin/bash"
}
```

3. **timeout.go** -- Add exec timeout constant:
```go
TimeoutExecCreate = 10 * time.Second  // For exec create/attach setup
// NOTE: No timeout for the exec session itself -- it is interactive with no predictable duration
```

4. **interface.go** -- Add 5 methods to DockerAPI and 1 method to DockerService:

DockerAPI additions (these match Docker SDK *client.Client method signatures exactly):
```go
ContainerExecCreate(ctx context.Context, containerID string, options container.ExecOptions) (types.IDResponse, error)
ContainerExecAttach(ctx context.Context, execID string, config container.ExecStartOptions) (types.HijackedResponse, error)
ContainerExecResize(ctx context.Context, execID string, options container.ResizeOptions) error
ContainerExecInspect(ctx context.Context, execID string) (container.ExecInspect, error)
ContainerExecStart(ctx context.Context, execID string, config container.ExecStartOptions) error
```

IMPORTANT: Verify the exact Docker SDK v27.5.1 method signatures before writing. Use `go doc github.com/docker/docker/client.Client.ContainerExecCreate` etc. to confirm parameter types. The research file suggests `container.ExecOptions` for create and `container.ExecAttachOptions` for attach, but the actual SDK may use different type names. Check:
- ContainerExecCreate return type: may be `types.IDResponse` or `container.ExecCreateResponse`
- ContainerExecAttach options type: may be `container.ExecAttachOptions` or `container.ExecStartOptions`

DockerService addition:
```go
// ExecContainer opens an interactive exec session -- returns a tea.ExecCommand for use with tea.Exec()
ExecContainer(containerID string, shell string) ExecCommand
```
Note: ExecContainer does NOT take ctx because the exec session is interactive and long-lived. The DockerExecCommand.Run() creates its own context.Background().

Actually, to keep the interface clean and avoid importing bubbletea in the docker package, define:
```go
// ExecCommand is the interface for exec session commands (matches tea.ExecCommand)
type ExecCommand interface {
    Run() error
    SetStdin(io.Reader)
    SetStdout(io.Writer)
    SetStderr(io.Writer)
}
```
Wait -- the docker package should NOT know about tea.ExecCommand. Instead, the `DockerExecCommand` struct in `exec.go` (created in Task 2) will implement `tea.ExecCommand` directly, and the DockerService interface just exposes a factory:
```go
NewExecCommand(containerID string, shell string) ExecCommand
```
But this pulls the ExecCommand interface into the docker package. A simpler approach: DON'T add exec to DockerService at all. The exec.go file creates `DockerExecCommand` which takes a `DockerAPI` directly. The TUI model already has access to the service/API layer.

REVISED APPROACH: Add the 5 methods to `DockerAPI` only. Do NOT add an exec method to `DockerService` -- the exec command is created directly in exec.go using `DockerAPI`. The analyze model will create a `DockerExecCommand` using a `DockerAPI` accessor on the service.

Add a method to DockerService to expose the raw API for exec purposes:
```go
// API returns the underlying DockerAPI for direct access (used by exec)
API() DockerAPI
```

5. **client.go** -- Add the API() accessor:
```go
func (c *Client) API() DockerAPI {
    return c.api
}
```

6. **mock.go** -- Add to MockDockerService:
- `APIFn func() DockerAPI` field + `API()` method (returns a MockDockerAPI by default)

Add to MockDockerAPI:
- `ContainerExecCreateFn` field + method
- `ContainerExecAttachFn` field + method
- `ContainerExecResizeFn` field + method
- `ContainerExecInspectFn` field + method
- `ContainerExecStartFn` field + method

Each mock method follows the existing pattern: check if Fn is set, call it, otherwise return zero value + nil error. For `ContainerExecAttach`, the zero-value return needs special handling since `types.HijackedResponse` contains `net.Conn` -- return a mock response with a pipe-based conn.

  </action>
  <verify>
Run `go build ./...` -- must compile with zero errors. All interface checks (`var _ DockerService = (*MockDockerService)(nil)` and `var _ DockerAPI = (*MockDockerAPI)(nil)`) must pass.
Run `go test ./internal/docker/...` -- existing tests must still pass.
Verify `golang.org/x/term` appears in go.mod.
  </verify>
  <done>
DockerAPI interface has 5 new exec methods. DockerService has API() accessor. MockDockerAPI and MockDockerService have corresponding mock implementations. ExecOptions type exists. golang.org/x/term is a direct dependency. All code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: DockerExecCommand, SIGWINCH handler, and TUI integration</name>
  <files>
    internal/docker/exec.go
    internal/tui/analyze/model.go
    internal/tui/common/messages.go
  </files>
  <action>
1. **internal/docker/exec.go** (NEW FILE) -- Create `DockerExecCommand` implementing `tea.ExecCommand`:

```go
//go:build !windows

package docker

import (
    "context"
    "fmt"
    "io"
    "os"
    "os/signal"
    "syscall"

    "github.com/docker/docker/api/types/container"
    "golang.org/x/term"
)
```

The struct:
```go
type DockerExecCommand struct {
    api         DockerAPI
    containerID string
    shell       string
    stdin       io.Reader
    stdout      io.Writer
    stderr      io.Writer
}

func NewDockerExecCommand(api DockerAPI, containerID, shell string) *DockerExecCommand {
    return &DockerExecCommand{
        api:         api,
        containerID: containerID,
        shell:       shell,
    }
}
```

SetStdin/SetStdout/SetStderr methods (trivial setters).

The Run() method (this is the critical orchestration):
a. Create exec: `ContainerExecCreate` with Cmd: []string{shell}, AttachStdin: true, AttachStdout: true, AttachStderr: true, Tty: true. Use `context.Background()` -- NOT a timeout context. Exec sessions are interactive.
b. Attach exec: `ContainerExecAttach` with Tty: true.
c. `defer attachResp.Close()`
d. Set terminal to raw mode: `term.MakeRaw(int(os.Stdin.Fd()))`. `defer term.Restore(fd, oldState)` IMMEDIATELY.
e. Start SIGWINCH monitoring goroutine BEFORE I/O copy.
f. Do initial resize: call `resizeExec()` once BEFORE starting I/O.
g. Start output copy goroutine: `go func() { io.Copy(stdout, attachResp.Reader); outputDone <- struct{}{} }()`
h. Start input copy goroutine: `go func() { io.Copy(attachResp.Conn, stdin); attachResp.CloseWrite() }()`
i. Wait on outputDone (indicates exec process exited, reader got EOF).
j. Return nil (or error from exec inspect if needed).

CRITICAL PITFALLS to handle:
- Terminal state MUST be restored even on panic (defer handles this).
- SIGWINCH goroutine MUST be stopped when exec ends (use done channel).
- Do NOT close os.Stdin. Let attachResp.Close() propagate to cleanup stdin copy goroutine.
- Use `os.Stdin.Fd()` for the fd, not stdin (which is the io.Reader set by tea.Exec -- but for raw mode we need the actual fd).

The monitorResize function:
```go
func monitorResize(ctx context.Context, api DockerAPI, execID string, fd int, done <-chan struct{}) {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGWINCH)
    defer signal.Stop(sigCh)
    for {
        select {
        case <-sigCh:
            resizeExec(ctx, api, execID, fd)
        case <-done:
            return
        case <-ctx.Done():
            return
        }
    }
}

func resizeExec(ctx context.Context, api DockerAPI, execID string, fd int) {
    width, height, err := term.GetSize(fd)
    if err != nil {
        return // best-effort
    }
    _ = api.ContainerExecResize(ctx, execID, container.ResizeOptions{
        Height: uint(height),
        Width:  uint(width),
    })
}
```

2. **Also create `internal/docker/exec_windows.go`** with a build tag `//go:build windows` that provides a stub:
```go
package docker

// DockerExecCommand is not fully supported on Windows.
// SIGWINCH is Unix-only; this stub provides basic exec without resize forwarding.
```
Include the same struct and methods but skip the SIGWINCH parts (no signal.Notify for SIGWINCH, no monitorResize). Use `term.MakeRaw`/`term.Restore` which DO work on Windows via `golang.org/x/term`.

Actually, simpler approach: use a build-tag-guarded file for just the SIGWINCH monitoring:
- `exec.go` (no build tag) -- contains DockerExecCommand, Run(), everything except monitorResize
- `resize_unix.go` (`//go:build !windows`) -- contains `monitorResize` and `resizeExec` using SIGWINCH
- `resize_windows.go` (`//go:build windows`) -- contains `monitorResize` as a no-op (just waits on done channel) and `resizeExec` using term.GetSize + ContainerExecResize

Wait, `syscall.SIGWINCH` does not exist on Windows. So the build tag approach is needed ONLY for the SIGWINCH constant reference. Let's do:
- `exec.go` -- all exec logic. `monitorResize` calls platform-specific `startResizeListener`.
- `resize_unix.go` (`//go:build !windows`) -- `func startResizeListener(sigCh chan<- os.Signal) { signal.Notify(sigCh, syscall.SIGWINCH) }`
- `resize_windows.go` (`//go:build windows`) -- `func startResizeListener(sigCh chan<- os.Signal) { /* no-op, SIGWINCH not available on Windows */ }`

This keeps exec.go platform-independent. Only the signal registration is platform-specific.

3. **internal/tui/common/messages.go** -- Add ExecFinishedMsg:
```go
// ExecFinishedMsg reports that a container exec session has ended
type ExecFinishedMsg struct {
    Err error
}
```

4. **internal/tui/analyze/model.go** -- Add "x" key handler and ExecFinishedMsg handler:

In the Update() function's key handler section, add a case for "x":
```go
case "x":
    if m.canExecOnSelected() {
        entry := m.selectedEntry()
        api := m.docker.API()
        cmd := docker.NewDockerExecCommand(api, entry.ID, "/bin/sh")
        return m, tea.Exec(cmd, func(err error) tea.Msg {
            return common.ExecFinishedMsg{Err: err}
        })
    }
```

Add helper method `canExecOnSelected()`:
```go
func (m *Model) canExecOnSelected() bool {
    if !m.canOperateOnSelected() {
        return false
    }
    entry := m.selectedEntry()
    return entry.Type == ResourceContainers && entry.Status != "" && !entry.IsUnused
    // IsUnused is true for non-running containers, so !IsUnused means running
}
```

Wait, check the existing code: `IsUnused: c.State != "running"`. So for running containers, `IsUnused == false`. The check should be:
```go
return entry.Type == ResourceContainers && !entry.IsUnused
```

Handle ExecFinishedMsg in the Update switch:
```go
case common.ExecFinishedMsg:
    if msg.Err != nil {
        m.statusMessage = fmt.Sprintf("Shell exited with error: %v", msg.Err)
    } else {
        m.statusMessage = "Shell session ended"
    }
    // Refresh data -- container state may have changed during exec
    m.loading = true
    return m, tea.Batch(
        m.fetchResources(),
        tea.Tick(3*time.Second, func(t time.Time) tea.Msg {
            return common.ClearStatusMsg{}
        }),
    )
```

When "x" is pressed on a non-running container, show a status message:
```go
case "x":
    if m.canOperateOnSelected() && m.selectedEntry().Type == ResourceContainers {
        if m.canExecOnSelected() {
            // ... launch exec
        } else {
            m.statusMessage = "Cannot exec: container is not running"
            return m, tea.Tick(3*time.Second, func(t time.Time) tea.Msg {
                return common.ClearStatusMsg{}
            })
        }
    }
```

Update the help text in View() to include "x: shell":
```go
styles.Help.Render("... | x: shell | ...")
```

  </action>
  <verify>
Run `go build ./...` -- must compile cleanly.
Run `go test ./internal/docker/... ./internal/tui/...` -- all existing tests must pass.
Run `go vet ./...` -- no issues.
Manual verification: `make build && ./bin/octo` -- open analyze view, select a running container, press "x". An interactive shell should open. Type `ls`, `whoami`, `exit`. TUI should resume cleanly.
  </verify>
  <done>
Pressing "x" on a running container in the analyze TUI opens an interactive shell with working stdin/stdout, terminal resize forwarding, and clean restoration. Pressing "x" on a non-running container shows "Cannot exec: container is not running". After exiting the shell, the TUI resumes with refreshed data.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with no errors
2. `go test ./...` all tests pass
3. `go vet ./...` no issues
4. Build and run: select a running container in analyze view, press "x", verify shell opens
5. Inside shell: run `ls`, `whoami`, resize terminal window, verify output adapts
6. Type `exit` -- TUI resumes with "Shell session ended" status message
7. Select a stopped container, press "x" -- shows "Cannot exec: container is not running"
8. After exec, container list is refreshed (verify with `docker stop` in another terminal during exec)
</verification>

<success_criteria>
- Interactive shell works with stdin/stdout inside running containers
- Terminal resize propagates to container during exec
- Clean terminal restoration after shell exit (no raw mode artifacts)
- Non-running containers show error message on exec attempt
- TUI resumes with refreshed data after exec
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-advanced-features/06-01-SUMMARY.md`
</output>
