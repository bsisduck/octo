---
phase: 06-advanced-features
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/docker/types.go
  - internal/docker/client.go
  - internal/docker/interface.go
  - internal/docker/mock.go
  - internal/tui/analyze/model.go
autonomous: false

must_haves:
  truths:
    - "Containers belonging to a Docker Compose project are visually grouped by project name in the analyze TUI"
    - "Containers without Compose labels display normally (no crash, no missing entries)"
    - "User can start/stop/restart all containers in a Compose project as a single action"
    - "Compose project grouping is derived from com.docker.compose.project label, not from external dependencies"
  artifacts:
    - path: "internal/docker/types.go"
      provides: "Labels field on ContainerInfo, ComposeGroup type"
      contains: "ComposeProjectLabel"
    - path: "internal/docker/client.go"
      provides: "Labels populated in ListContainers, project-level lifecycle methods"
      contains: "ComposeProjectLabel"
    - path: "internal/tui/analyze/model.go"
      provides: "Compose-grouped container display in View()"
      contains: "ComposeGroup"
  key_links:
    - from: "internal/docker/client.go"
      to: "internal/docker/types.go"
      via: "Populates ContainerInfo.Labels from Docker API Container.Labels"
      pattern: "Labels.*c\\.Labels"
    - from: "internal/tui/analyze/model.go"
      to: "internal/docker/types.go"
      via: "Groups ResourceEntry by ComposeProjectLabel for rendering"
      pattern: "ComposeProjectLabel|ComposeGroup"
---

<objective>
Add Docker Compose awareness: containers belonging to Compose projects are visually grouped by project name in the analyze TUI, and users can start/stop/restart all containers in a project as a single action.

Purpose: Users managing Docker Compose stacks need to see which containers belong together and manage them as logical groups (R27).
Output: Compose-grouped container view in analyze TUI with project-level lifecycle operations.
</objective>

<execution_context>
@/Users/kamilkrawczyk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kamilkrawczyk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-advanced-features/06-RESEARCH.md
@.planning/phases/06-advanced-features/06-01-SUMMARY.md
@internal/docker/types.go
@internal/docker/client.go
@internal/docker/interface.go
@internal/docker/mock.go
@internal/tui/analyze/model.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Labels on ContainerInfo, Compose grouping types, project-level lifecycle methods</name>
  <files>
    internal/docker/types.go
    internal/docker/client.go
    internal/docker/interface.go
    internal/docker/mock.go
  </files>
  <action>
1. **types.go** -- Add `Labels` field to `ContainerInfo`:
```go
type ContainerInfo struct {
    ID      string
    Name    string
    Image   string
    Status  string
    State   string
    Created time.Time
    Ports   string
    Size    int64
    Labels  map[string]string  // NEW: Container labels (includes Compose metadata)
}
```

Add Compose constants and grouping types:
```go
const (
    ComposeProjectLabel = "com.docker.compose.project"
    ComposeServiceLabel = "com.docker.compose.service"
)

// ComposeGroup groups containers belonging to the same Docker Compose project
type ComposeGroup struct {
    ProjectName string
    Containers  []ContainerInfo
}

// GroupByComposeProject splits containers into Compose groups and ungrouped.
// Containers without Compose labels are returned as ungrouped.
// Groups are sorted alphabetically by project name.
func GroupByComposeProject(containers []ContainerInfo) (groups []ComposeGroup, ungrouped []ContainerInfo) {
    projectMap := make(map[string][]ContainerInfo)
    for _, c := range containers {
        if c.Labels == nil {
            ungrouped = append(ungrouped, c)
            continue
        }
        project, ok := c.Labels[ComposeProjectLabel]
        if !ok || project == "" {
            ungrouped = append(ungrouped, c)
            continue
        }
        projectMap[project] = append(projectMap[project], c)
    }

    for name, containers := range projectMap {
        groups = append(groups, ComposeGroup{
            ProjectName: name,
            Containers:  containers,
        })
    }
    // Sort groups alphabetically
    sort.Slice(groups, func(i, j int) bool {
        return groups[i].ProjectName < groups[j].ProjectName
    })
    return groups, ungrouped
}
```
Add `"sort"` to imports in types.go.

2. **client.go** -- Populate Labels in ListContainers:
In the `ListContainers` method, add `Labels: c.Labels` to the ContainerInfo construction:
```go
result[i] = ContainerInfo{
    ID:      truncateID(c.ID, 12),
    Name:    name,
    Image:   c.Image,
    Status:  c.Status,
    State:   c.State,
    Created: time.Unix(c.Created, 0),
    Ports:   ports,
    Size:    c.SizeRw,
    Labels:  c.Labels,  // NEW
}
```

Also populate Labels in `GetStoppedContainers` similarly.

Add project-level lifecycle methods to client.go:
```go
// StartComposeProject starts all stopped containers in a Compose project.
// Skips already-running containers. Returns count of containers started.
func (c *Client) StartComposeProject(ctx context.Context, projectName string) (int, error) {
    containers, err := c.ListContainers(ctx, true)
    if err != nil {
        return 0, fmt.Errorf("failed to list containers: %w", err)
    }

    started := 0
    for _, ct := range containers {
        if ct.Labels == nil {
            continue
        }
        if ct.Labels[ComposeProjectLabel] != projectName {
            continue
        }
        if ct.State == "running" {
            continue // skip already running
        }
        if err := c.api.ContainerStart(ctx, ct.ID, container.StartOptions{}); err != nil {
            return started, fmt.Errorf("failed to start container %s: %w", ct.Name, err)
        }
        started++
    }
    return started, nil
}

// StopComposeProject stops all running containers in a Compose project.
// Skips already-stopped containers. Returns count of containers stopped.
func (c *Client) StopComposeProject(ctx context.Context, projectName string) (int, error) {
    containers, err := c.ListContainers(ctx, true)
    if err != nil {
        return 0, fmt.Errorf("failed to list containers: %w", err)
    }

    stopped := 0
    for _, ct := range containers {
        if ct.Labels == nil {
            continue
        }
        if ct.Labels[ComposeProjectLabel] != projectName {
            continue
        }
        if ct.State != "running" {
            continue // skip non-running
        }
        if err := c.api.ContainerStop(ctx, ct.ID, container.StopOptions{}); err != nil {
            return stopped, fmt.Errorf("failed to stop container %s: %w", ct.Name, err)
        }
        stopped++
    }
    return stopped, nil
}

// RestartComposeProject restarts all containers in a Compose project.
// Returns count of containers restarted.
func (c *Client) RestartComposeProject(ctx context.Context, projectName string) (int, error) {
    containers, err := c.ListContainers(ctx, true)
    if err != nil {
        return 0, fmt.Errorf("failed to list containers: %w", err)
    }

    restarted := 0
    for _, ct := range containers {
        if ct.Labels == nil {
            continue
        }
        if ct.Labels[ComposeProjectLabel] != projectName {
            continue
        }
        if err := c.api.ContainerRestart(ctx, ct.ID, container.StopOptions{}); err != nil {
            return restarted, fmt.Errorf("failed to restart container %s: %w", ct.Name, err)
        }
        restarted++
    }
    return restarted, nil
}
```

3. **interface.go** -- Add project-level lifecycle methods to DockerService:
```go
// Compose project lifecycle
StartComposeProject(ctx context.Context, projectName string) (int, error)
StopComposeProject(ctx context.Context, projectName string) (int, error)
RestartComposeProject(ctx context.Context, projectName string) (int, error)
```

4. **mock.go** -- Add mock implementations:
```go
// In MockDockerService struct:
StartComposeProjectFn  func(ctx context.Context, projectName string) (int, error)
StopComposeProjectFn   func(ctx context.Context, projectName string) (int, error)
RestartComposeProjectFn func(ctx context.Context, projectName string) (int, error)

// Method implementations following existing pattern:
func (m *MockDockerService) StartComposeProject(ctx context.Context, projectName string) (int, error) {
    if m.StartComposeProjectFn != nil {
        return m.StartComposeProjectFn(ctx, projectName)
    }
    return 0, nil
}
// ... same for Stop and Restart
```

  </action>
  <verify>
Run `go build ./...` -- must compile cleanly.
Run `go test ./internal/docker/...` -- all tests pass.
Run `go vet ./...` -- no issues.
Write a quick test (or use go test -run) to verify GroupByComposeProject: create a slice of ContainerInfo with mixed labels (some with Compose project, some without, some with nil Labels), verify correct grouping and ungrouped separation.
  </verify>
  <done>
ContainerInfo has Labels field populated from Docker API. ComposeGroup type and GroupByComposeProject function exist and correctly group containers. Labels are nil-safe. Project-level Start/Stop/Restart methods work. All compile-time interface checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Compose-grouped container display in analyze TUI with project-level actions</name>
  <files>
    internal/tui/analyze/model.go
  </files>
  <action>
Modify the analyze TUI to display containers grouped by Compose project when viewing the containers section.

1. **Update ResourceEntry** to support Compose grouping:
Add fields to ResourceEntry:
```go
type ResourceEntry struct {
    // ... existing fields ...
    ComposeProject string  // Compose project name (empty if not part of a project)
    ComposeService string  // Compose service name
    IsProjectHeader bool   // True if this entry is a Compose project group header
    ProjectName     string // Project name for project header entries
}
```

2. **Update fetchResources()** to group containers by Compose project:
In the containers section of fetchResources(), after fetching containers, use GroupByComposeProject to organize them:

```go
if m.filterType == ResourceAll || m.filterType == ResourceContainers {
    containers, err := m.docker.ListContainers(ctx, true)
    if err != nil {
        warnings = append(warnings, fmt.Sprintf("containers: %v", err))
    } else {
        if m.filterType == ResourceAll {
            entries = append(entries, ResourceEntry{
                Type:       ResourceContainers,
                Name:       "Containers",
                IsCategory: true,
            })
        }

        // Group by Compose project
        groups, ungrouped := docker.GroupByComposeProject(containers)

        // Add grouped containers
        for _, group := range groups {
            // Project header (collapsible group header)
            entries = append(entries, ResourceEntry{
                Type:            ResourceContainers,
                Name:            fmt.Sprintf("[%s] (%d containers)", group.ProjectName, len(group.Containers)),
                IsProjectHeader: true,
                ProjectName:     group.ProjectName,
                Selectable:      true,  // Selectable for project-level operations
            })
            for _, c := range group.Containers {
                if m.showDangling && c.State == "running" {
                    continue
                }
                serviceName := ""
                if c.Labels != nil {
                    serviceName = c.Labels[docker.ComposeServiceLabel]
                }
                entries = append(entries, ResourceEntry{
                    Type:           ResourceContainers,
                    ID:             c.ID,
                    Name:           c.Name,
                    Size:           c.Size,
                    Status:         c.Status,
                    Created:        c.Created,
                    Extra:          c.Image,
                    IsUnused:       c.State != "running",
                    Selectable:     true,
                    ComposeProject: group.ProjectName,
                    ComposeService: serviceName,
                })
            }
        }

        // Add ungrouped containers
        for _, c := range ungrouped {
            if m.showDangling && c.State == "running" {
                continue
            }
            entries = append(entries, ResourceEntry{
                Type:       ResourceContainers,
                ID:         c.ID,
                Name:       c.Name,
                Size:       c.Size,
                Status:     c.Status,
                Created:    c.Created,
                Extra:      c.Image,
                IsUnused:   c.State != "running",
                Selectable: true,
            })
        }
    }
}
```

3. **Update View()** to render Compose groups visually:
In the entry rendering loop, add special rendering for project headers and compose-grouped containers:

```go
if entry.IsProjectHeader {
    // Render as a group header with compose icon
    line = styles.Section.Render(fmt.Sprintf("  [compose] %s", entry.Name))
} else if entry.ComposeProject != "" {
    // Indent compose-grouped containers
    serviceLabel := ""
    if entry.ComposeService != "" {
        serviceLabel = fmt.Sprintf(" (%s)", entry.ComposeService)
    }
    name := entry.Name
    if len(name) > 26 {
        name = name[:23] + "..."
    }
    // ... format with indentation showing membership
    line = fmt.Sprintf("    %-28s%s %s%s", name, serviceLabel, styles.Label.Render(sizeStr), status)
    line = styles.Normal.Render(line)
}
```

4. **Add project-level keybindings:**
When a project header is selected, "s"/"t"/"r" operate on the entire project:

```go
case "s":
    if m.canOperateOnSelected() {
        entry := m.selectedEntry()
        if entry.IsProjectHeader {
            return m, m.startComposeProject(entry.ProjectName)
        } else if entry.Type == ResourceContainers {
            return m, m.startSelectedContainer()
        }
    }
case "t":
    if m.canOperateOnSelected() {
        entry := m.selectedEntry()
        if entry.IsProjectHeader {
            return m, m.stopComposeProject(entry.ProjectName)
        } else if entry.Type == ResourceContainers {
            return m, m.stopSelectedContainer()
        }
    }
case "r":
    if m.canOperateOnSelected() {
        entry := m.selectedEntry()
        if entry.IsProjectHeader {
            return m, m.restartComposeProject(entry.ProjectName)
        } else if entry.Type == ResourceContainers {
            return m, m.restartSelectedContainer()
        }
    } else {
        m.loading = true
        return m, m.fetchResources()
    }
```

5. **Add Compose project lifecycle command functions:**
```go
func (m Model) startComposeProject(projectName string) tea.Cmd {
    return func() tea.Msg {
        ctx, cancel := context.WithTimeout(context.Background(), docker.TimeoutAction*3) // longer for bulk
        defer cancel()
        count, err := m.docker.StartComposeProject(ctx, projectName)
        if err != nil {
            return DataMsg{Entries: m.entries, Warnings: append(m.warnings, fmt.Sprintf("Failed to start project %s: %v", projectName, err))}
        }
        _ = count // will be reflected in refreshed data
        return m.fetchResources()()
    }
}
// ... same pattern for stop and restart
```

6. **Update help text** to mention Compose operations:
```go
styles.Help.Render("... | s/t/r: start/stop/restart (project or container) | x: shell | ...")
```

7. **Update ClipboardText** on ResourceEntry to include Compose info when present:
```go
if e.ComposeProject != "" {
    parts = append(parts, fmt.Sprintf("Compose Project: %s", e.ComposeProject))
}
if e.ComposeService != "" {
    parts = append(parts, fmt.Sprintf("Compose Service: %s", e.ComposeService))
}
```

  </action>
  <verify>
Run `go build ./...` -- must compile.
Run `go test ./internal/tui/...` -- existing tests pass.
Manual verification: Build and run, open analyze view. If you have a Docker Compose stack running, containers should appear grouped under "[compose] project-name (N containers)" headers. Ungrouped containers should appear normally below.
  </verify>
  <done>
Compose-managed containers are visually grouped by project name. Project headers show container count. Individual containers within groups are indented with service name. Start/stop/restart on a project header affects all containers in that project. Ungrouped containers display normally. Nil labels do not cause crashes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify Compose grouping and exec integration</name>
  <what-built>Docker Compose awareness with project grouping and lifecycle operations</what-built>
  <how-to-verify>
    1. Start a Docker Compose stack (any project with 2+ services): `docker compose up -d`
    2. Run `make build && ./bin/octo` -- open analyze view
    3. Verify Compose containers appear grouped under a "[compose] project-name" header
    4. Verify non-Compose containers appear normally (ungrouped)
    5. Select the project header, press "s" to start all, "t" to stop all, "r" to restart all
    6. Verify project-level operations affect all containers in the group
    7. Select an individual Compose container, press "x" to shell into it (from Plan 01)
    8. Verify the service name appears next to the container name
    9. If no Compose stack available: verify all containers appear normally without grouping headers
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with no errors
2. `go test ./...` all tests pass
3. Compose containers are grouped by project name in analyze view
4. Non-Compose containers display normally (graceful degradation)
5. Project-level start/stop/restart works on all containers in a group
6. Nil/missing Labels do not cause panics
7. Exec from Plan 01 still works on Compose-grouped containers
</verification>

<success_criteria>
- Compose project grouping visible in analyze TUI container list
- Project-level lifecycle operations (start/stop/restart all) work correctly
- Containers without Compose labels display normally
- No crashes on nil labels or missing Compose keys
- Visual grouping uses indentation and project headers
</success_criteria>

<output>
After completion, create `.planning/phases/06-advanced-features/06-02-SUMMARY.md`
</output>
